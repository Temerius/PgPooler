# Протокол PostgreSQL (wire protocol) в PgPooler

PgPooler работает как **прозрачный прокси**: мы не интерпретируем и не меняем содержимое сообщений, только разбираем границы сообщений и пересылаем их между клиентом и бэкендом побайтово.

Все многобайтовые целые в протоколе — **big-endian (network byte order)**.

---

## 1. Два формата сообщений

### 1.1. Первое сообщение от клиента (без байта типа)

Используется только для **первого** сообщения в сессии (со стороны клиента):

| Смещение | Размер | Описание |
|----------|--------|----------|
| 0        | 4      | **Int32** — длина сообщения *в байтах*, **включая эти 4 байта**. |
| 4        | len−4  | Тело сообщения. |

**Итого в буфере:** ровно `len` байт.

Возможные первые сообщения:
- **SSLRequest** — 8 байт: `len=8` (4 байта) + код `80877103` (4 байта).
- **StartupMessage** — например, 119 байт: `len` + версия протокола + пары «параметр = значение» (user, database и т.д.).

В коде это обрабатывает `try_extract_length_prefixed_message()`: читаем 4 байта → получаем `len` → забираем из буфера ровно `len` байт.

### 1.2. Все остальные сообщения (с байтом типа)

Используются для всех последующих сообщений (и от клиента, и от бэкенда):

| Смещение | Размер | Описание |
|----------|--------|----------|
| 0        | 1      | **Byte1** — тип сообщения (например `'R'`, `'p'`, `'Z'`). |
| 1        | 4      | **Int32** — длина *содержимого* сообщения в байтах, **включая эти 4 байта** (байт типа не входит). |
| 5        | len−4  | Тело (зависит от типа). |

**Итого в буфере:** ровно `1 + len` байт.

В коде это обрабатывает `try_extract_typed_message()`: читаем байт типа и 4 байта длины → получаем `len` → забираем из буфера `total = 1 + len` байт.

---

## 2. Роль байтов в нашем разборе

- **Первые 4 байта** первого сообщения клиента — длина первого сообщения (Int32, big-endian).
- **Первый байт** каждого типизированного сообщения — тип; по нему мы только логируем и пересылаем, не разбираем тело.
- **Байты 1–4** типизированного сообщения — Int32 длина «содержимого» (включая само поле длины); полный размер сообщения = `1 + len`.

Мы **не парсим** тела сообщений (пароли, параметры, запросы и т.д.) — только определяем границы и пересылаем.

---

## 3. Типы сообщений, которые мы видим в логах

| Байт | Тип   | Направление   | Кратко |
|------|-------|---------------|--------|
| `R`  | 0x52  | backend→client | Authentication (запрос пароля, OK, MD5, SASL и т.д.) |
| `p`  | 0x70  | client→backend | Password / SASL / GSS response |
| `Z`  | 0x5A  | backend→client | ReadyForQuery (бэкенд готов к следующей команде) |
| `Q`  | 0x51  | client→backend | Query (текст SQL) |
| `T`  | 0x54  | backend→client | RowDescription |
| `D`  | 0x44  | backend→client | DataRow |
| `C`  | 0x43  | backend→client | CommandComplete |
| `E`  | 0x45  | backend→client | ErrorResponse |
| `S`  | 0x53  | backend→client | ParameterStatus |
| `K`  | 0x4B  | backend→client | BackendKeyData |
| …    |       |                | И другие по спецификации PostgreSQL. |

Полный список и форматы — в [документации PostgreSQL](https://www.postgresql.org/docs/current/protocol-message-formats.html).

---

## 4. Как мы обрабатываем протокол

1. **Клиент подключается**  
   Читаем первое сообщение через `try_extract_length_prefixed_message()`.

2. **Если это SSLRequest (8 байт)**  
   Пересылаем бэкенду; бэкенд присылает один байт `'S'` или `'N'`. Пересылаем его клиенту. После этого клиент пришлёт второе «первое» сообщение — уже StartupMessage.

3. **Если это StartupMessage**  
   Пересылаем бэкенду. Переходим в режим **проксирования по границам типизированных сообщений**.

4. **Дальше в обе стороны**  
   В цикле вызываем `try_extract_typed_message()`: как только в буфере есть полное сообщение (`1 + len` байт), забираем его и пересылаем на другую сторону. Тело не разбираем.

Итого: **прозрачное проксирование** — мы только выставляем границы сообщений и пересылаем байты; аутентификация, запросы и ответы обрабатываются самим PostgreSQL на бэкенде и клиентом (psql, DBeaver и т.д.).

---

## 5. Файлы в этом каталоге

- **message.hpp / message.cpp** — разбор границ сообщений:
  - `try_extract_length_prefixed_message()` — первое сообщение от клиента;
  - `try_extract_typed_message()` — все остальные сообщения;
  - `extract_startup_parameter()` — извлечение параметров StartupMessage (user, database и т.д.);
  - все длины и порядок байт по спецификации PostgreSQL.

---

## 6. Маршрутизация (какие поля извлекаем)

Для выбора бэкенда имеет смысл маршрутизировать по:

| Поле        | Откуда              | Зачем |
|-------------|---------------------|--------|
| **user**    | StartupMessage      | Разные пользователи → разные хосты (например reporting → реплика). |
| **database**| StartupMessage      | Разные БД могут жить на разных серверах. |

**client_ip** извлекаем и логируем для аудита и ACL; для «куда слать запрос» обычно не используется. Опционально позже можно добавить **application_name** (тоже из StartupMessage) для маршрутизации.
