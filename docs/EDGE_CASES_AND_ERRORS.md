# Edge cases: пул переполнен и PostgreSQL отказывает

Клиент (DBeaver, psql и т.д.) ожидает ответы в формате **протокола PostgreSQL**. Мы не придумываем свой формат — при отказе в соединении мы шлём обычное сообщение **ErrorResponse** (тип `'E'`), как это делает сам PostgreSQL.

---

## 1. Два сценария отказа

| Сценарий | Когда | Что делаем |
|----------|--------|------------|
| **Пул переполнен** | Все `pool_size` соединений к выбранному бэкенду уже заняты (или мы пока просто считаем лимит и не даём новое соединение). | Не открываем новое соединение к PG. Клиенту отправляем **ErrorResponse** с SQLSTATE `53300` и текстом в духе «connection limit reached» / «too many connections», затем закрываем клиентское соединение. |
| **PostgreSQL отказывает** | Мы пытаемся открыть соединение к бэкенду, но PG уже исчерпал `max_connections` (или сеть/сервер недоступен). | Клиенту отправляем **ErrorResponse**: по возможности пересылаем то, что вернул PG (если успели прочитать `'E'` от бэкенда), иначе формируем своё с тем же кодом `53300` и понятным текстом, затем закрываем клиентское соединение. |

В обоих случаях клиент видит обычную ошибку PostgreSQL (как «too many connections»), а не наш кастомный протокол.

---

## 2. Формат ErrorResponse в протоколе PostgreSQL

Сообщение **ErrorResponse** (см. [Message Formats](https://www.postgresql.org/docs/current/protocol-message-formats.html)):

- **Byte1** — `'E'` (0x45).
- **Int32** — длина *содержимого* сообщения в байтах (включая эти 4 байта; байт типа не входит). То есть полный размер сообщения = **1 + length**.
- **Тело** — последовательность полей, каждое: **Byte1** (код поля) + **строка** (заканчивается `\0`). Список заканчивается **Byte1(0)**.

Минимально нужные поля для «too many connections»:

| Код | Значение | Смысл |
|-----|----------|--------|
| `S` | `FATAL` или `ERROR` | Severity. |
| `C` | `53300` | SQLSTATE (too_many_connections). |
| `M` | Текст ошибки | Сообщение, которое видит пользователь. |

Пример тела (без учёта байта типа и 4 байт длины):

- `S` + `"FATAL\0"` + `C` + `"53300\0"` + `M` + `"sorry, too many clients already\0"` + `\0`

Итого мы формируем байты: `'E'` + Int32(length) + тело, и отправляем клиенту как одно сообщение. После этого соединение с клиентом можно закрыть.

---

## 3. Как устроен пул (как в PgBouncer/Odyssey)

Пул **держит уже открытые** соединения к PostgreSQL:

- При старте или по требованию открываем соединения к бэкенду (до `pool_size`) и держим их **подключёнными**, но без привязанного клиента (idle).
- **Клиент подключается к нам** → мы не открываем новый сокет к PG «на каждый запрос», а **выдаём ему одно из свободных соединений пула** (acquire). Это соединение уже подключено к PostgreSQL.
- **Клиент отключается** (или завершает транзакцию в transaction mode) → мы **возвращаем** это соединение в пул (release), оно снова idle и может быть выдано другому клиенту.

То есть: **соединения в пуле уже открыты к PostgreSQL**; мы лишь «подключаем» и «отключаем» клиента к одному из них. Реализация полного reuse (transaction/statement mode) — отдельный шаг; сначала достаточно ограничивать число соединений к бэкенду (pool_size) и при исчерпании пула или отказе PG возвращать клиенту ErrorResponse в формате выше.
